package ccomp.parser_hw;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.ListIterator;
import java.util.Map;
import java.util.Stack;

import SFE.Compiler.AnyType;
import SFE.Compiler.ArrayType;
import SFE.Compiler.BitwiseOperator;
import SFE.Compiler.BlockStatement;
import SFE.Compiler.BusType;
import SFE.Compiler.CompileTimeOperator;
import SFE.Compiler.FloatConstant;
import SFE.Compiler.Function;
import SFE.Compiler.GetDbExpression;
import SFE.Compiler.InputStatement;
import SFE.Compiler.IntConstant;
import SFE.Compiler.IntType;
import SFE.Compiler.LvalExpression;
import SFE.Compiler.OperationExpression;
import SFE.Compiler.Pointer;
import SFE.Compiler.PointerType;
import SFE.Compiler.ProtoAssignmentStatement;
import SFE.Compiler.PutDbStatement;
import SFE.Compiler.RestrictedSignedIntType;
import SFE.Compiler.RestrictedUnsignedIntType;
import SFE.Compiler.StructType;
import SFE.Compiler.Type;
import SFE.Compiler.TypeHeirarchy;
import SFE.Compiler.Operators.ArrayAccessOperator;
import SFE.Compiler.Operators.CStyleCast;
import SFE.Compiler.Operators.GetPointerOperator;
import SFE.Compiler.Operators.MinusOperator;
import SFE.Compiler.Operators.Operator;
import SFE.Compiler.Operators.PlusOperator;
import SFE.Compiler.Operators.PointerAccessOperator;
import SFE.Compiler.Operators.StructAccessOperator;
import SFE.Compiler.Operators.TimesOperator;
import SFE.Compiler.Operators.UnaryMinusOperator;
import SFE.Compiler.Operators.UnaryPlusOperator;
import ccomp.CDatabaseFunctions;
import ccomp.CMemoryMap;
import ccomp.parser.CParser;
import ccomp.parser.CScanner;
import ccomp.parser_hw.HLL_ASTNodes.AssignmentStatement;
import ccomp.parser_hw.HLL_ASTNodes.BinaryOpExpression;
import ccomp.parser_hw.HLL_ASTNodes.CastExpression;
import ccomp.parser_hw.HLL_ASTNodes.CompoundStatement;
import ccomp.parser_hw.HLL_ASTNodes.ConditionalExpression;
import ccomp.parser_hw.HLL_ASTNodes.Constant;
import ccomp.parser_hw.HLL_ASTNodes.Declaration;
import ccomp.parser_hw.HLL_ASTNodes.Expression;
import ccomp.parser_hw.HLL_ASTNodes.FunctionCall;
import ccomp.parser_hw.HLL_ASTNodes.FunctionDefinition;
import ccomp.parser_hw.HLL_ASTNodes.Identifier;
import ccomp.parser_hw.HLL_ASTNodes.IfStatement;
import ccomp.parser_hw.HLL_ASTNodes.LoopStatement;
import ccomp.parser_hw.HLL_ASTNodes.MultiExpression;
import ccomp.parser_hw.HLL_ASTNodes.MultiVariableDeclaration;
import ccomp.parser_hw.HLL_ASTNodes.Program;
import ccomp.parser_hw.HLL_ASTNodes.ReturnStatement;
import ccomp.parser_hw.HLL_ASTNodes.Statement;
import ccomp.parser_hw.HLL_ASTNodes.StructTypeSpecification;
import ccomp.parser_hw.HLL_ASTNodes.TypeSpecification;
import ccomp.parser_hw.HLL_ASTNodes.UnaryOpExpression;
import ccomp.parser_hw.HLL_ASTNodes.VariableDeclaration;

/**
 * NOTE: You will get compile errors unless you also include on your build path the java files in /gensrc,
 * which are generated by invoking the compiler generators beaver and flex. The shell script build-ccomp.sh
 * does this for you, as does invoking make from the /frontend folder.
 */
public class CCompiler {
  private Reader file;
  public CCompiler(Reader file) {
    this.file = file;
    typetable = new HashMap();
    functable = new HashMap();
    functable2 = new HashMap();
    
    builtinTypes();
    builtinFunctions();
  }
  public static void main_(String[] args) throws IOException {
    SFE.Compiler.Program p = new SFE.Compiler.Program();
    CCompiler cc = new CCompiler(new BufferedReader(new FileReader(args[0])));
    cc.compileProgram(p);
    System.out.println("Parse successful.");
  }

  // The "value" returned when returning from a void method. Conveniently also works for the default return value
  // for default-int functions.
  private SFE.Compiler.Expression VoidRetVal = new SFE.Compiler.UnaryOpExpression(new UnaryPlusOperator(), IntConstant.valueOf(0));
  private Map<String, Type> typetable;
  private Map<String, FunctionDefinition> functable;
  private Map<String, Function> functable2;
  private BlockStatement globalInit;
  public Collection<String> getDefinedTypeNames() {
    return new HashSet<String>(typetable.keySet());
  }
  public void compileProgram(SFE.Compiler.Program program) {
    CParser cp = new CParser();
    Program p = null;
    try {
      p = (Program) cp.parse(new CScanner(file));
    } catch (IOException e) {
      throw new RuntimeException(e);
    } catch (beaver.Parser.Exception e) {
      System.out.println("Error parsing .c file: "+e.getLocalizedMessage());
      //e.printStackTrace();
    }

    setProgram_(program, p);
  }
  private static class CLexicalScope {
    private Stack<String> scopeNames = new Stack();
    private Stack<HashSet<String>> scope = new Stack();
    public void pushScope(String name) {
      scope.push(new HashSet());
      scopeNames.push(name);
    }
    public void popScope() {
      scope.pop();
      scopeNames.pop();
    }
    public String getID(String name) {
      //Search backwards through this lexical scope, and return the prefix-prepended name.
      //If we get to the bottom, return the name as-is (C global var)
      boolean found = false;
      if (scope.isEmpty()) {
        throw new RuntimeException("Assertion error - empty scope");
      }

      for(ListIterator itr = scope.listIterator(scope.size()), itr2 = scopeNames.listIterator(scope.size());
          itr.hasPrevious(); ) {
        HashSet<String> got = (HashSet<String>)itr.previous();
        String prefix = (String)itr2.previous();
        if (got.contains(name)) {
          found = true; //Start prepending prefixes.
        }
        if (found) {
          name = prefix + "$" + name;
        }
      }

      return name;
    }
    private String getAddID(String name) {
      StringBuffer prefix = new StringBuffer();
      for(String k : scopeNames) {
        prefix.append(k);
        prefix.append("$");
      }
      if (prefix.length() == 0) {
        return name;
      }
      return prefix+name;
    }
    public LvalExpression addVar(String string, Type cType, boolean isOutput) {
      if (scope.peek().contains(string)){
        throw new RuntimeException("Variable declared twice: "+string);
      }
      scope.peek().add(string);
      return Function.getVars().addVar(getAddID(string), cType, false, isOutput);
    }
  }
  private void addGlobalVariable(CLexicalScope scope, VariableDeclaration q) {
    //Check if already defined
    if (Function.getVars().getVar(q.name.identifier) != null){
      throw new RuntimeException("Global variable declared twice: "+q.name.identifier);
    }
    //Special: Global variable named __stdout_buffer is an output variable.
    boolean isOutput = false;
    boolean isInput = false;
    if (q.name.identifier.equals("__stdout_buffer")){
      isOutput = true;
    } else if (q.name.identifier.equals("__stdin_buffer")){
      isInput = true;
    }
    
    LvalExpression gvar = Function.getVars().addVar(q.name.identifier, getCType(q.type, q.name), false, isOutput);
    if (isInput){
      globalInit.addStatement(new InputStatement(gvar));
    } else {
      if (q.initializer == null){
        //Default int setting for global variables shouldn't surprise anyone, because programmers should know
        //not to rely on the initialization of global variables.
        //System.err.println("Warning - initializing global variable "+q.name+" with value 0");
        //throw new RuntimeException("Global variables must be declared with an initial value: "+q.name);
      }
      globalInit.addStatement(asId(gvar, IntConstant.ZERO));
      //Initializer.
      if (q.initializer != null){
        if (q.initializer instanceof MultiExpression){
          MultiExpression me = (MultiExpression)q.initializer;
          if (me.size() > gvar.size()){
            throw new RuntimeException("Cannot assign array initializer "+me+" to lval " + gvar);
          }
          for(int i = 0; i < me.size(); i++){
            globalInit.addStatement(new ProtoAssignmentStatement(
                new SFE.Compiler.BinaryOpExpression(new ArrayAccessOperator(), gvar, IntConstant.valueOf(i)), 
                new SFE.Compiler.UnaryOpExpression(new UnaryPlusOperator(), getExpr(scope, me.get(i), globalInit)),
                null
                ));
          }
        }
      }
    }
  }
  private int malloc_num = CMemoryMap.HEAP; //start of heap memory
  private static class Malloc {
    public LvalExpression data;
    public Pointer ptr;
  }
  private Malloc malloc(Type pointedToType, boolean isOutput) {
    if (pointedToType instanceof ArrayType){
      throw new RuntimeException("I don't know how to malloc an array");
    }
    Malloc toRet = new Malloc();
    int num = malloc_num;
    toRet.data = Function.getVars().addVar("__malloc"+num, pointedToType, false, isOutput);
    toRet.ptr = new Pointer(pointedToType, new LvalExpression[]{toRet.data}, num, num);
    
    //Advance
    malloc_num++;
    
    //Return
    return toRet;
  }
  private void setProgram_(SFE.Compiler.Program program, Program p) {
    //Lexical scope for the program. Initially, global scope.
    CLexicalScope main_s = new CLexicalScope();
    globalInit = new BlockStatement();
    for(Object q : p){
      if (q instanceof FunctionDefinition){
        addFunction((FunctionDefinition)q);
      } else if (q instanceof StructTypeSpecification){
        addStructType((StructTypeSpecification)q);
      } else if (q instanceof VariableDeclaration){
        VariableDeclaration q2 = (VariableDeclaration)q;
        if (q2.type.spec.startsWith("typedef")){ //Strangely, typedefs parse through as variable declarations.
          addTypeDef(q2.type.spec.split(" ",2)[1],q2.name);
        } else {
          addGlobalVariable(main_s, q2);
        }
      }
    }
    String nameOfMain = "compute";
    //We will only add one function object to the created program.
    FunctionDefinition main_d = functable.get(nameOfMain);
    if (main_d != null){
      setProgramWithCompute(main_s, main_d, program);
      return;
    }
    main_d = functable.get("main");
    if (main_d != null){
      setProgramWithCStyleMain(main_s, main_d, program);
      return;
    }
    throw new RuntimeException("Program does not fit into either possible run case - no method called "+nameOfMain+", and no standard C main found.");
  }
  private void setProgramWithCompute(CLexicalScope main_s, FunctionDefinition main_d, SFE.Compiler.Program program){
    String nameOfMain = main_d.functionNameAndArgs.identifier;
    Function main = functable2.get(nameOfMain);
    main.setOutput(true);

    //Create new lexical scope for function call
    main_s.pushScope(nameOfMain);
    
    //Get the input (should be first arg of main, a pointer.)
    VariableDeclaration input = null;
    VariableDeclaration output = null;

    //Create the input variables (X), and assign inputstatements (X <- input)
    for(VariableDeclaration v : main_d.functionNameAndArgs.args) {
      if (v.name.identifier.equals("input")){
        input = v;
      } else 
      if (v.name.identifier.equals("output")){
        output = v;
      } else {
        throw new RuntimeException("Currently, the main method must take a pointer to struct called input, and a pointer to struct called output, and no other arguments");
      }
    }
    if (input == null || output== null){
      throw new RuntimeException("Currently, the main method must take a pointer to struct called input, and a pointer to struct called output, and nothing else");
    }
  
    //Add the input variable (X)
    PointerType inPtr_t = ((PointerType)getCType(input.type, input.name));
    //Add the variable for the data of Xptr
    Malloc Xmalloc = malloc(inPtr_t.getPointedToType(), false);
    
    //Fill the input with input statements
    main.addStatement(new InputStatement(Xmalloc.data));
    //Make the input argument to the main (a pointer to the malloc'ed data)
    LvalExpression Xptr = main_s.addVar(input.name.identifier, inPtr_t, false);
    main.addStatement(asId(Xptr, Xmalloc.ptr));
    
    //Make the return value
    LvalExpression Yreturn = main_s.addVar("__"+nameOfMain+"__", getCType(main_d.returnType, main_d.functionNameAndArgs), true);

    //Allocate space for the output struct
    PointerType outPtr_t = ((PointerType)getCType(output.type, output.name));
    Malloc Ymalloc = malloc(outPtr_t.getPointedToType(), true);
    //Zero out output struct
    LvalExpression Ydata = Ymalloc.data;
    main.addStatement(asId(Ydata, IntConstant.ZERO));

    //Make the output argument to the main
    LvalExpression Yptr = main_s.addVar(output.name.identifier, getCType(output.type, output.name), false);
    main.addStatement(asId(Yptr, Ymalloc.ptr));

    //Initialize globals //(This strange order is so that all inputStatements are together, starting at output line 0)
    main.addStatement(globalInit);    
    
    //Expand the call to the main
    BlockStatement returnValueSts = new BlockStatement();
    SFE.Compiler.Expression returnValue_ = expandStatement(main_s, main_d.block, returnValueSts);
    if (returnValue_ == null) {
      //Default to returning 0.
      returnValue_ = VoidRetVal;
    }
    main.addStatement(returnValueSts);
    main.addStatement(asId(Yreturn, returnValue_));
    
    //re-assign the Ydata to itself to make sure the outputs are in the right order.
    main.addStatement(asId(Ydata, Ydata));
  
    //reassign stdout to itself to fix the numbering
    LvalExpression __stdout_buffer = Function.getVars().getVar("__stdout_buffer");
    if (__stdout_buffer != null){
      main.addStatement(asId(__stdout_buffer, __stdout_buffer));
    }
      
    program.addFunction(main);
  }
  
  private void setProgramWithCStyleMain(CLexicalScope main_s, FunctionDefinition main_d, SFE.Compiler.Program program){
    String nameOfMain = main_d.functionNameAndArgs.identifier;
    Function main = functable2.get(nameOfMain);
    main.setOutput(true);

    //Create new lexical scope for function call
    main_s.pushScope(nameOfMain);
    
    //There should be two arguments - int argc, char** argv.
    VariableDeclaration argc = main_d.functionNameAndArgs.args.get(0);
    VariableDeclaration argv = main_d.functionNameAndArgs.args.get(1);
    if (!argc.type.isSubType(new TypeSpecification("int")) || !argv.type.isSubType(new TypeSpecification("char**"))){
      throw new RuntimeException("Arguments to standard C main must have type int and char**, in that order");
    }

    {
      //Add argc (for now, 0 args.)
      LvalExpression argcLval = main_s.addVar(argc.name.identifier, typetable.get("int"), false);
      main.addStatement(asId(argcLval, IntConstant.ZERO));

      //Add argv (for now, null.)
      LvalExpression argvLval = main_s.addVar(argv.name.identifier, 
          new PointerType(new PointerType(typetable.get("char"))), false);
      main.addStatement(asId(argvLval, IntConstant.ZERO));
    }

    //Make the return value
    if (!main_d.returnType.isSubType(new TypeSpecification("int"))){
      throw new RuntimeException("Return type of standard c main must be int");
    }
    LvalExpression Yreturn = main_s.addVar("__"+nameOfMain+"__", typetable.get("int"), true);
    
    //Initialize globals
    main.addStatement(globalInit);
    
    //Expand the call to the main
    BlockStatement returnValueSts = new BlockStatement();
    SFE.Compiler.Expression returnValue_ = expandStatement(main_s, main_d.block, returnValueSts);
    if (returnValue_ == null) {
      //Default to returning 0.
      returnValue_ = VoidRetVal;
    }
    main.addStatement(returnValueSts);
    main.addStatement(asId(Yreturn, returnValue_));
    
    //reassign stdout to itself to fix the numbering
    LvalExpression __stdout_buffer = Function.getVars().getVar("__stdout_buffer");
    if (__stdout_buffer != null){
      main.addStatement(asId(__stdout_buffer, __stdout_buffer));
    }
    
    program.addFunction(main);
  }
  
  private void addTypeDef(String type, Identifier name) {
    typetable.put(name.identifier, getCType(new TypeSpecification(type), null));
  }
  private void addStructType(StructTypeSpecification q) {
    typetable.put(q.structType +" "+ q.structName, getCType(q, null));
  }
  private void addFunction(FunctionDefinition fd) {
    Identifier funcid = fd.functionNameAndArgs;
    if (functable.containsKey(funcid.identifier)) {
      throw new RuntimeException("Duplicate function name: "+funcid.identifier);
    }
    functable.put(funcid.identifier, fd);

    functable2.put(funcid.identifier, new Function(funcid.identifier, getCType(fd.returnType, null)));
  }
  /**
   * Returns whatever the return value of the function is.
   *
   * If there is no return statement, returns null.
   */
  private SFE.Compiler.Expression expandStatement(CLexicalScope scope, Statement block, BlockStatement bs) {
    if (block instanceof CompoundStatement) {
      CompoundStatement cs = (CompoundStatement)block;
      ArrayList<Statement> s = cs.statements;
      scope.pushScope("block");
      for(Declaration d : cs.declarations) {
        if (d instanceof MultiVariableDeclaration){
          MultiVariableDeclaration d2 = (MultiVariableDeclaration)d;
          for(VariableDeclaration v : d2){
            LvalExpression var = scope.addVar(v.name.identifier, getCType(v.type, v.name), false);
            bs.addStatement(asId(var, IntConstant.ZERO));
          }
        } else {
          throw new RuntimeException("I don't know how to handle "+d+" declaration inside of a block.");
        }
      }
      SFE.Compiler.Expression returnValue = null;
      for(Statement p : s) {
        returnValue = expandStatement(scope, p, bs);
        if (returnValue != null) {
          break;
        }
      }
      scope.popScope();

      //No return statement.
      return returnValue;
    } else if (block instanceof AssignmentStatement) {
      //evaluate it like an expression
      getExpr(scope, (AssignmentStatement)block, bs);
      return null;
    } else if (block instanceof ReturnStatement) {
      ReturnStatement rs = (ReturnStatement)block;
      if (rs.toRet == null) {
        return VoidRetVal;
      }
      return getExpr(scope, rs.toRet, bs);
    } else if (block instanceof Expression){
      getExpr(scope, (Expression)block, bs); //But disregard the value returned.
      return null;
    } else if (block instanceof LoopStatement){
      LoopStatement loop = (LoopStatement) block;
      expandStatement(scope, loop.pre, bs);
      //Make a new block to hold the statements for the loop.
      BlockStatement loopBlock = new BlockStatement();
      expandStatement(scope, loop.block, loopBlock);
      SFE.Compiler.LoopStatement loop2 = new SFE.Compiler.LoopStatement(getExpr(scope, loop.enter, bs), loopBlock);
      bs.addStatement(loop2);
      return null;
    } else if (block instanceof IfStatement){
      IfStatement fib = (IfStatement)block;
      SFE.Compiler.Expression cond = getExpr(scope, fib.cond, bs);
      BlockStatement the = new BlockStatement();
      scope.pushScope("then");
      SFE.Compiler.Expression retValThe = expandStatement(scope, fib.the, the);
      scope.popScope();
      BlockStatement els = new BlockStatement();
      scope.pushScope("else");
      SFE.Compiler.Expression retValEls = expandStatement(scope, fib.els, els);
      scope.popScope();
      if (retValThe != null || retValEls != null){
        throw new RuntimeException("Blocks inside an if statement cannot return values at this time.");
      }
      SFE.Compiler.IfStatement fi = new SFE.Compiler.IfStatement(cond, the, els, ":ifstatement_"+(if_condition_uid++));
      bs.addStatement(fi);
      //If statements cannot return at this point in time.
      return null;
    } else {
      throw new RuntimeException("I don't know how to coerce to statement: "+block);
    }
  }
  private static int if_condition_uid = 0;
  private SFE.Compiler.Expression getExpr(CLexicalScope scope, Expression ein, BlockStatement bs) {
    if (ein instanceof BinaryOpExpression) {
      BinaryOpExpression bo = (BinaryOpExpression) ein;
      SFE.Compiler.Expression lExpr = getExpr(scope, bo.left, bs);
      SFE.Compiler.Expression rExpr = getExpr(scope, bo.right, bs);
      //Do the types of the operands have an effect on the operator?
      SFE.Compiler.BinaryOpExpression boe = new SFE.Compiler.BinaryOpExpression(bo.operator, lExpr, rExpr);
      boe.metaType = CTypeForBOE(boe);
      if (bo.operator instanceof BitwiseOperator){
        ((BitwiseOperator)bo.operator).setBitwiseEncoding(boe.metaType);
      }
      return boe;
    } else if (ein instanceof UnaryOpExpression) {
      UnaryOpExpression bo = (UnaryOpExpression) ein;
      //Do the types of the operands have an effect on the operator?
      SFE.Compiler.Expression mExpr = getExpr(scope, bo.middle, bs);
      SFE.Compiler.UnaryOpExpression uoe = new SFE.Compiler.UnaryOpExpression(bo.operator, mExpr);
      uoe.metaType = CTypeForUOE(uoe);
      if (bo.operator instanceof BitwiseOperator){
        ((BitwiseOperator)bo.operator).setBitwiseEncoding(uoe.metaType);
      }
      return uoe;
    } else if (ein instanceof Constant) {
      Constant c = (Constant)ein;
      return getConstant(c);
    } else if (ein instanceof Identifier) {
      Identifier identifier = (Identifier) ein;
      LvalExpression lv =  Function.getVars().getVar(scope.getID(identifier.identifier));
      if (lv == null) {
        throw new RuntimeException("No such variable: "+scope.getID(identifier.identifier));
      }
      lv.metaType = lv.getDeclaredType();
      return lv;
    } else if (ein instanceof CastExpression) {
      CastExpression cein = (CastExpression)ein;
      Type castType = getCType(cein.type, null);
      SFE.Compiler.Expression toRet = new SFE.Compiler.UnaryOpExpression(new CStyleCast(castType), getExpr(scope, cein.toCast, bs));
      toRet.metaType = castType;
      return toRet;
    } else if (ein instanceof MultiExpression) {
      MultiExpression me = (MultiExpression) ein;
      if (me.size() == 0) {
        throw new RuntimeException("Assertion error");
      }
      ArrayList<SFE.Compiler.Expression> exprs = new ArrayList();
      for(Expression q : me){
        exprs.add(getExpr(scope, q, bs));
      }
      //GCC returns the result of the last expression. This may be undefined behavior.
      return exprs.get(exprs.size()-1);
    } else if (ein instanceof ConditionalExpression){
      ConditionalExpression cein = (ConditionalExpression)ein;
            
      SFE.Compiler.Expression cond = getExpr(scope, cein.cond, bs);
      LvalExpression muxLval = scope.addVar(":conditional_exp_"+(if_condition_uid++), new BusType(1), false);
      
      BlockStatement the = new BlockStatement();
      scope.pushScope("then");
      SFE.Compiler.Expression theRet = getExpr(scope, cein.the, the);
      scope.popScope();
      
      BlockStatement els = new BlockStatement();
      scope.pushScope("else");
      SFE.Compiler.Expression elsRet = getExpr(scope, cein.els, els);
      scope.popScope();
      
      Type unionMetaType = CTypeForBOE(theRet.metaType, new MinusOperator(), elsRet.metaType);
      muxLval.metaType = unionMetaType;
      
      //Add to the an AS of the expression value to the mux lval
      the.addStatement(asId(muxLval, theRet));
      //Add to els an AS of the expression value to the mux lval
      els.addStatement(asId(muxLval, elsRet));

      SFE.Compiler.IfStatement fi = new SFE.Compiler.IfStatement(cond, the, els, ":ifstatement_"+(if_condition_uid++));
      bs.addStatement(fi);
      return muxLval;
    } else if (ein instanceof FunctionCall){
      FunctionCall fc = (FunctionCall)ein;
      
      SFE.Compiler.Expression asBuiltIn = builtinFunctionCall(scope, fc, bs);
      if (asBuiltIn != null){
        return asBuiltIn;
      }
      
      String funcName = fc.funcName.identifier;
      FunctionDefinition toCall = functable.get(funcName);
      if (toCall == null){
        throw new RuntimeException("No function definition for "+funcName);
      }
      Identifier toCallInfo = toCall.functionNameAndArgs;
      
      ArrayList<SFE.Compiler.Expression> inputExprs = new ArrayList();
      for(Expression q : fc.args){
        inputExprs.add(getExpr(scope, q, bs));
      }
      if (inputExprs.size() != toCallInfo.args.size()){
        throw new RuntimeException("Wrong number of arguments to function "+funcName);
      }
      
      //Create new function scope for our call
      scope.pushScope(funcName);
      //Initialize the inputs to the function
      for(int i = 0; i < toCallInfo.args.size(); i++){
        VariableDeclaration vd = toCallInfo.args.get(i);
        LvalExpression addVar = scope.addVar(vd.name.identifier, getCType(vd.type, vd.name), false);
        bs.addStatement(asId(addVar, inputExprs.get(i)));
      }
      
      SFE.Compiler.Expression returnValue_ = expandStatement(scope, toCall.block, bs); 
      scope.popScope();
      return returnValue_;      
    } else if (ein instanceof AssignmentStatement){
      AssignmentStatement ast = (AssignmentStatement) ein;
      if (ast.LHS_lookup == null){
        throw new RuntimeException("Not yet implemented: AssignmentStatement as expression without LHS lookup");
      }
      SFE.Compiler.Expression lhsLookup = getExpr(scope, ast.LHS_lookup, bs);
      //Wrap the RHS in a cast to the LHS's metatype. This is used for assigning long ints to ints, etc.
      CStyleCast cc = new CStyleCast(lhsLookup.metaType);
      //Make the assignment
      SFE.Compiler.Expression rhs = getExpr(scope, ast.RHS, bs);
      if (ast.binaryOperator != null){
        //What would be the metatype of performing the binary operator now?
        //Make sure this check doesn't add new statements.
        SFE.Compiler.BinaryOpExpression boe = new SFE.Compiler.BinaryOpExpression(ast.binaryOperator, lhsLookup, rhs);
        boe.metaType = CTypeForBOE(boe);
        if (ast.binaryOperator instanceof BitwiseOperator){
          ((BitwiseOperator)ast.binaryOperator).setBitwiseEncoding(boe.metaType);
        }
        ProtoAssignmentStatement newState = new ProtoAssignmentStatement(lhsLookup, rhs, ast.binaryOperator, cc);
        bs.addStatement(newState);
        return newState.getResolvedLHS();
      } else {
        /*
        if (!(rhs instanceof OperationExpression)){
            SFE.Compiler.Expression newRhs = new SFE.Compiler.UnaryOpExpression(new UnaryPlusOperator(), rhs);
            newRhs.metaType = rhs.metaType;
            rhs = newRhs;
        }
        */
        ProtoAssignmentStatement newState = new ProtoAssignmentStatement(lhsLookup, rhs, cc);
        bs.addStatement(newState);
        return newState.getResolvedLHS();
      }
    } else {
      throw new RuntimeException("I don't know how to coerce to expression: "+ein);
    }
  }
  private SFE.Compiler.Expression builtinFunctionCall(CLexicalScope scope, FunctionCall fc, BlockStatement bs) {
    //Build a new getexpression with the args
    ArrayList<SFE.Compiler.Expression> args = new ArrayList();
    for(int i = 0; i < fc.args.size(); i++){
      args.add(getExpr(scope, fc.args.get(i), bs));
    }
    
    if (fc.funcName.identifier.equals(CDatabaseFunctions.GETDB_NAME)){
      //Create new function scope for our call
      scope.pushScope(CDatabaseFunctions.GETDB_NAME);
      //Initialize the inputs to the function
      LvalExpression[] addrs = new LvalExpression[args.size()];
      for(int i = 0; i < args.size(); i++){
        LvalExpression addVar = scope.addVar("addr"+i, new IntType(), false);
        bs.addStatement(asId(addVar, args.get(i)));
        addrs[i] = addVar;
      }
      
      Type expectedGetType = typetable.get("int"); //For now, assume gets return ints.
      GetDbExpression getdb = new GetDbExpression(expectedGetType, addrs); 
      scope.popScope();
      return getdb;
    }
    if (fc.funcName.identifier.equals(CDatabaseFunctions.PUTDB_NAME)){
      //For put, last arg is the value to be stored, the first n-1 are the address.
      
      //Create new function scope for our call
      scope.pushScope(CDatabaseFunctions.PUTDB_NAME);
      //Initialize the inputs to the function
      LvalExpression[] addrs = new LvalExpression[args.size()-1];
      for(int i = 0; i < args.size() - 1; i++){
        LvalExpression addVar = scope.addVar("addr"+i, new IntType(), false);
        bs.addStatement(asId(addVar, args.get(i)));
        addrs[i] = addVar;
      }
      LvalExpression value = scope.addVar("value", new IntType(), false);
      bs.addStatement(asId(value, args.get(args.size() - 1)));
      
      bs.addStatement(new PutDbStatement(addrs, value)); 
      scope.popScope();
      return VoidRetVal;
    } 
    return null;
  }
  private Type CTypeForUOE(SFE.Compiler.UnaryOpExpression uoe) {
    Type middle = uoe.getMiddle().metaType;

    if (uoe.op instanceof PointerAccessOperator){
      return getPointedToType(middle);
    } else if (uoe.op instanceof StructAccessOperator){
      StructType st = (StructType)middle;
      return st.fromFieldName(((StructAccessOperator)uoe.op).getField());
    } else if (uoe.op instanceof GetPointerOperator){
      return new PointerType(middle);
    } else if (middle instanceof IntType){ 
      //Only handle the case where left and right are integers, for now.
      //Integer promotions
      middle = integerPromote(middle);
      
      return middle;
    } else {
      throw new RuntimeException("I don't know how to form the C-type for UOE "+uoe.op+" "+middle);
    }
  }
  private Type CTypeForBOE(SFE.Compiler.BinaryOpExpression boe) {
    Type left = boe.getLeft().metaType;
    Type right = boe.getRight().metaType;
    return CTypeForBOE(left, boe.op, right);
  }
  private Type getPointedToType(Type t){
    if (t instanceof PointerType){
      return ((PointerType) t).getPointedToType();
    } else if (t instanceof ArrayType){
      return ((ArrayType) t).getBaseType();
    } else {
      throw new RuntimeException("I don't know how to treat type "+t+" like a pointer");
    }
  }
  private boolean isPOAType(Type t){
    return (t instanceof PointerType) || (t instanceof ArrayType); 
  }
  private Type CTypeForBOE(Type left, Operator op, Type right){
    //Integer-Integer binary ops
    if (op instanceof ArrayAccessOperator){
      ArrayType at = (ArrayType)left;
      return at.getBaseType();
    } else if (op instanceof PlusOperator && (isPOAType(left) || isPOAType(right))){
      Type ptType = left;
      Type intType = right;
      if (!isPOAType(ptType)){
        ptType = right;
        intType = left;
      }
      if (!(intType instanceof IntType)){
        throw new RuntimeException("Cannot add "+intType+" to a pointer");
      }
      return ptType;
    } else if (op instanceof MinusOperator && isPOAType(left)){
      if (isPOAType(right)){
        //We can subtract pointers, but they must have the same type.
        throw new RuntimeException("Subtraction of pointers not yet implemented");
      }
      if (!(right instanceof IntType)){
        throw new RuntimeException("Cannot subtract "+right+" off of a pointer");
      }
      return left;
    } else if (left instanceof IntType && right instanceof IntType){
      //Integer promotions
      left = integerPromote(left);
      right = integerPromote(right);
      
      //Usual arithmetic conversions
     //1. If both operands have the same type, no further conversion is needed.
      if (TypeHeirarchy.equals(left, right)){
        return left;
      }
     //2. If both operands are of the same integer type (signed or unsigned), the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.
      boolean leftSigned = left instanceof RestrictedSignedIntType;
      boolean rightSigned = right instanceof RestrictedSignedIntType;
      if (leftSigned == rightSigned){
        return TypeHeirarchy.looseUnion(left, right);
      }
     //3. If the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type is converted to the type of the operand with unsigned integer type.
      int leftBits = IntType.getBits((IntType)left);
      int rightBits = IntType.getBits((IntType)right);
      if (!leftSigned && leftBits >= rightBits){
        return left; //Negative values of right will be added to the max of left plus 1.
      }
      if (!rightSigned && rightBits >= leftBits){
        return right; //Negative values of left will be added to the max of left plus 1.
      }
     //4. If the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type is converted to the type of the operand with signed integer type.
      if (!leftSigned && TypeHeirarchy.isSubType(left, right)){
        return right; //right is signed
      }
      if (!rightSigned && TypeHeirarchy.isSubType(right, left)){
        return left; //left is signed
      }
     //5. Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type. Specific operations can add to or modify the semantics of the usual arithmetic operations.
      throw new RuntimeException("I don't know how to form the C-type for operating on "+left+" and "+right);
    } else {
      throw new RuntimeException("I don't know how to form the C-type for BOE "+left+" "+op+" "+right);
    }
  }
  private Type integerPromote(Type c) {
    //If an int can hold the op, return int
    Type i_t = typetable.get("int");
    if (TypeHeirarchy.isSubType(c, i_t)){
      return i_t;
    }
    //If an unsigned int can hold the op, return unsigned int
    Type ui_t = typetable.get("unsigned int");
    if (TypeHeirarchy.isSubType(c, ui_t)){
      return ui_t;
    }
    //Otherwise, the type does not need promotion
    return c;
  }
  private void builtinTypes() {

    typetable.put("void", null); //null is handled correctly for void
    for(String signString : new String[]{"", "signed", "unsigned"}){
      typetable.put(join(signString,"char"), intType(signString,16)); //"At least 16 bits in size"
      typetable.put(join(signString,"short"), intType(signString,16)); //"At least 16 bits in size"
      typetable.put(join(signString,"short int"), intType(signString,16)); //"At least 16 bits in size"
      typetable.put(join(signString,"int"), intType(signString,32)); //"At least 16 bits in size" - but 32 is needed for compliance with the stdlib.h on my system?
      typetable.put(join(signString,"long"), intType(signString,64)); //"At least 32 bits in size"
      typetable.put(join(signString,"long int"), intType(signString,64)); //"At least 32 bits in size"
      typetable.put(join(signString,"long long"), intType(signString,64)); //"At least 64 bits in size"
      typetable.put(join(signString,"long long int"), intType(signString,64)); //"At least 64 bits in size"
    }
  }

  private void builtinFunctions() {
    //Reserve the function names getdb and putdb.
    addFunction(new FunctionDefinition(new Identifier(CDatabaseFunctions.GETDB_NAME), null));
    addFunction(new FunctionDefinition(new Identifier(CDatabaseFunctions.PUTDB_NAME), null));
  }
  private int constant_string_uid = 0;
  private SFE.Compiler.Expression getConstant(Constant e) {
    String val = e.value+"";
    if (e.constType.equals("string")){
      int addressOfList = CMemoryMap.STRING_TABLE + constant_string_uid;
      int N = ((String)e.value).length();
      LvalExpression[] list = new LvalExpression[N];
      Type charType = typetable.get("char");
      for(int i = 0; i < N; i++){
        list[i] = Function.getVars().addVar("__strtable"+constant_string_uid, charType, false, false);
        constant_string_uid ++;
        globalInit.addStatement(asId(list[i], IntConstant.valueOf((int)((String)e.value).charAt(i))));
      }
      Pointer toRet = new Pointer(charType, list, addressOfList, addressOfList);
      toRet.metaType = toRet.getType();
      return toRet;
    } else if (e.constType.equals("fp")){
      throw new RuntimeException("Floating point constants not yet handled: "+val);
    } else if (e.constType.startsWith("int")){
      String[] possibilities;
      //Behavior based on
      //http://publib.boulder.ibm.com/infocenter/zos/v1r12/index.jsp?topic=%2Fcom.ibm.zos.r12.cbclx01%2Flit_integer.htm
      //using the table "outside of C99 and C++0x", i.e. maximum compatibility with old code.
      if (e.constType.contains("hex") || e.constType.contains("octal")){
        possibilities = new String[]{"int", "unsigned int", "long int", "unsigned long int"};
      } else if (e.constType.contains("decimal")){
        possibilities = new String[]{"int", "long int", "unsigned long int"};
      } else {
        throw new RuntimeException("I don't know how to handle int of constant type: "+e.constType);
      }
      
      String numVal;
      if (val.toLowerCase().endsWith("ull")){ 
        numVal = allButLast(val, 3);
        possibilities = new String[]{"unsigned long long int"}; 
      } else
      if (val.toLowerCase().endsWith("ll")){
        numVal = allButLast(val, 2);
        possibilities = new String[]{"long long int", "unsigned long long int"}; 
      } else
      if (val.toLowerCase().endsWith("ul")){
        numVal = allButLast(val, 2);
        possibilities = new String[]{"unsigned long int"}; 
      } else
      if (val.toLowerCase().endsWith("u")){
        numVal = allButLast(val, 1);
        possibilities = new String[]{"unsigned int", "unsigned long int"};
      } else
      if (val.toLowerCase().endsWith("l")){
        numVal = allButLast(val, 1);
        possibilities = new String[]{"long int", "unsigned long int"}; 
      } else {
        numVal = val;
      }
      
      FloatConstant toRet = FloatConstant.valueOf(numVal);
      for(String q : possibilities){
        Type gotType = typetable.get(q);
        if (TypeHeirarchy.isSubType(toRet.getType(), gotType)){
          toRet.metaType = gotType;
          break; //Keep the first that works.
        }
      }
      if (toRet.metaType == null){
        throw new RuntimeException("Integer too large to represent: "+val);
      }
      return toRet;
    } else {
      throw new RuntimeException("I don't know how to handle const of type: "+e.constType+" @ "+val);
    }
  }
  private String allButLast(String numVal, int i) {
    return numVal.substring(0,numVal.length() - i);
  }
  /**
   * UnaryPlusOperator is used to make assignments of varying sizes. Use this instead
   * of simply assigning one thing to another, because that rarely works.
   */
  private SFE.Compiler.Statement asId(LvalExpression lval, SFE.Compiler.Expression rhs) {
    if (rhs instanceof OperationExpression && !(((OperationExpression)rhs).getOperator() instanceof CompileTimeOperator)){
      return as(lval, rhs);
    } else {
      return as(lval, new SFE.Compiler.UnaryOpExpression(new UnaryPlusOperator(), rhs));
    }
  }
  private SFE.Compiler.AssignmentStatement as(LvalExpression lval, SFE.Compiler.Expression rhs) {
    return new SFE.Compiler.AssignmentStatement(lval, rhs);
  }
  private String join(String a, String b) {
    if (a.equals("")){
      return b;
    }
    return a+" "+b;
  }
  private Type intType(String signString, int i) {
    if (signString.equals("unsigned")){
      return new RestrictedUnsignedIntType(i);
    }
    return new RestrictedSignedIntType(i);
  }
  public Type getCType(TypeSpecification ts, Identifier name) {
    Type got = getCTypeBase(ts);
    
    //TODO: support syntax int (*a)[5], which distinguishes a pointer to an array of length 5
    //from int* a[5], an array of 5 pointers to ints.
    
    if (name != null) {
      //the base type may be a pointer (i.e. array of pointers, or just a pointer)
      if (name.pointer != null){
        for(char c : name.pointer.spec.toCharArray()){
          if (c == '*'){
            got = new PointerType(got);
          } else if (c == ' '){
            continue;
          } else {
            throw new RuntimeException("Unrecognized pointer character: "+c);
          }
        }
      }
      
      //Read dimensions of array back to front
      ArrayList<Expression> sizes = name.arraySizes;
      if (!sizes.isEmpty()) {
        for(ListIterator<Expression> itr = sizes.listIterator(sizes.size()); itr.hasPrevious();) {
          Expression k = itr.previous();
          got = new ArrayType(got, toInt(k));
        }
      }
    }
    
    if (got == null){
      //Default int
      return typetable.get("int");
    }
    return got;
  }
  private Type getCTypeBase(TypeSpecification ts) {
    if (ts instanceof StructTypeSpecification){
      StructType toRet = new StructType();
      StructTypeSpecification ts2 = (StructTypeSpecification) ts;
      for(VariableDeclaration v : ts2.components){
        Type cType = getCType(v.type, v.name);
        toRet.addField(v.name.identifier, cType);
      }
      return toRet;
    }
    
    if (!typetable.containsKey(ts.spec)){
      throw new RuntimeException("No such type: "+ts);
    }
    return typetable.get(ts.spec);
  }
  private int toInt(Expression k) {
    if (k instanceof Constant) {
      return Integer.parseInt(""+((Constant)k).value);
    } else if (k instanceof MultiExpression){
      MultiExpression m = (MultiExpression)k;
      if (m.size() == 1){
        return toInt(m.get(0));
      } else {
        throw new RuntimeException("I don't know how to coerce multiexpression "+m+" to an int.");
      }
    } else if (k instanceof UnaryOpExpression) {
      UnaryOpExpression kop = (UnaryOpExpression) k;
      if (kop.operator instanceof UnaryMinusOperator){
        return -toInt(kop.middle);
      }
      throw new RuntimeException("Constant handling of unary op expressions TODO");
    } else if (k instanceof BinaryOpExpression) {
      BinaryOpExpression kop = (BinaryOpExpression) k;
      if (kop.operator instanceof PlusOperator) {
        return toInt(kop.left)+toInt(kop.right);
      } 
      if (kop.operator instanceof MinusOperator) {
        return toInt(kop.left)-toInt(kop.right);
      } 
      if (kop.operator instanceof TimesOperator) {
        return toInt(kop.left)*toInt(kop.right);
      }
      throw new RuntimeException("Constant handling of binary op expressions TODO");
    }

    throw new RuntimeException("I don't know how to coerce "+k+" to a constant.");
  }
}
